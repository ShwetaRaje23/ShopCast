{"version":3,"sources":["meteor://ðŸ’»app/packages/autoupdate/autoupdate_cordova.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sH","file":"/packages/autoupdate.js","sourcesContent":["var DEBUG_TAG = 'METEOR CORDOVA DEBUG (autoupdate_cordova.js) ';\nvar log = function (msg) {\n  console.log(DEBUG_TAG + msg);\n};\n\n// This constant was picked by testing on iOS 7.1\n// We limit the number of concurrent downloads because iOS gets angry on the\n// application when a certain limit is exceeded and starts timing-out the\n// connections in 1-2 minutes which makes the whole HCP really slow.\nvar MAX_NUM_CONCURRENT_DOWNLOADS = 30;\nvar MAX_RETRY_COUNT = 5;\n\nvar autoupdateVersionCordova = __meteor_runtime_config__.autoupdateVersionCordova || \"unknown\";\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !! ClientVersions.findOne({\n    _id: 'version-cordova',\n    version: {$ne: autoupdateVersionCordova}\n  });\n};\n\nvar writeFile = function (directoryPath, fileName, content, cb) {\n  var fail = function (err) {\n    cb(new Error(\"Failed to write file: \", err), null);\n  };\n\n  window.resolveLocalFileSystemURL(directoryPath, function (dirEntry) {\n    var success = function (fileEntry) {\n      fileEntry.createWriter(function (writer) {\n        writer.onwrite = function (evt) {\n          var result = evt.target.result;\n          cb(null, result);\n        };\n        writer.onerror = fail;\n        writer.write(content);\n      }, fail);\n    };\n\n    dirEntry.getFile(fileName, {\n      create: true,\n      exclusive: false\n    }, success, fail);\n  }, fail);\n};\n\nvar restartServer = function (location) {\n  log('restartServer with location ' + location);\n  var fail = function (err) { log(\"Unexpected error in restartServer: \" + err.message) };\n  var httpd = cordova && cordova.plugins && cordova.plugins.CordovaUpdate;\n\n  if (! httpd) {\n    fail(new Error('no httpd'));\n    return;\n  }\n\n  var startServer = function (cordovajsRoot) {\n    httpd.startServer({\n      'www_root' : location,\n      'cordovajs_root': cordovajsRoot\n    }, function (url) {\n      if (Package.reload) {\n        Package.reload.Reload._reload();\n      } else {\n        window.location.reload();\n      }\n    }, fail);\n  };\n\n  httpd.getCordovajsRoot(function (cordovajsRoot) {\n    startServer(cordovajsRoot);\n  }, fail);\n};\n\nvar hasCalledReload = false;\nvar updating = false;\nvar localPathPrefix = null;\n\nvar onNewVersion = function () {\n  var ft = new FileTransfer();\n  var urlPrefix = Meteor.absoluteUrl() + '__cordova';\n  HTTP.get(urlPrefix + '/manifest.json', function (err, res) {\n    if (err || ! res.data) {\n      log('Failed to download the manifest ' + (err && err.message) + ' ' + (res && res.content));\n      return;\n    }\n\n    updating = true;\n    ensureLocalPathPrefix(_.bind(downloadNewVersion, null, res.data));\n  });\n};\n\nvar downloadNewVersion = function (program) {\n  var urlPrefix = Meteor.absoluteUrl() + '__cordova';\n  var manifest = _.clone(program.manifest);\n  var version = program.version;\n  var ft = new FileTransfer();\n\n  manifest.push({ url: '/index.html?' + Random.id() });\n\n  var versionPrefix = localPathPrefix + version;\n\n  var queue = [];\n  _.each(manifest, function (item) {\n    if (! item.url) return;\n\n    var url = item.url;\n    url = url.replace(/\\?.+$/, '');\n\n    queue.push(url);\n  });\n\n  var afterAllFilesDownloaded = _.after(queue.length, function () {\n    var wroteManifest = function (err) {\n      if (err) {\n        log(\"Failed to write manifest.json: \" + err);\n        // XXX do something smarter?\n        return;\n      }\n\n      // success! downloaded all sources and saved the manifest\n      // save the version string for atomicity\n      writeFile(localPathPrefix, 'version', version, function (err) {\n        if (err) {\n          log(\"Failed to write version: \" + err);\n          return;\n        }\n\n        // don't call reload twice!\n        if (! hasCalledReload) {\n          var location = uriToPath(localPathPrefix + version);\n          restartServer(location);\n        }\n      });\n    };\n\n    writeFile(versionPrefix, 'manifest.json',\n              JSON.stringify(program, undefined, 2), wroteManifest);\n  });\n\n  var downloadUrl = function (url) {\n    console.log(DEBUG_TAG + \"start downloading \" + url);\n    // Add a cache buster to ensure that we don't cache an old asset.\n    var uri = encodeURI(urlPrefix + url + '?' + Random.id());\n\n    // Try to download the file a few times.\n    var tries = 0;\n    var tryDownload = function () {\n      ft.download(uri, versionPrefix + encodeURI(url), function (entry) {\n        if (entry) {\n          console.log(DEBUG_TAG + \"done downloading \" + url);\n          // start downloading next queued url\n          if (queue.length)\n            downloadUrl(queue.shift());\n          afterAllFilesDownloaded();\n        }\n      }, function (err) {\n        // It failed, try again if we have tried less than 5 times.\n        if (tries++ < MAX_RETRY_COUNT) {\n          log(\"Download error, will retry (#\" + tries + \"): \" + uri);\n          tryDownload();\n        } else {\n          log('Download failed: ' + JSON.stringify(err) + \", source=\" + err.source + \", target=\" + err.target);\n        }\n      });\n    };\n\n    tryDownload();\n  };\n\n  _.times(Math.min(MAX_NUM_CONCURRENT_DOWNLOADS, queue.length), function () {\n    var nextUrl = queue.shift();\n    // XXX defer the next download so iOS doesn't rate limit us on concurrent\n    // downloads\n    Meteor.setTimeout(downloadUrl.bind(null, nextUrl), 50);\n  });\n};\n\nvar retry = new Retry({\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function () {\n  var appId = __meteor_runtime_config__.appId;\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", appId, {\n    onError: function (err) {\n      Meteor._debug(\"autoupdate subscription failed:\", err);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    }\n  });\n  if (Package.reload) {\n    var checkNewVersionDocument = function (doc) {\n      var self = this;\n      if (doc.version !== autoupdateVersionCordova) {\n        onNewVersion();\n      }\n    };\n\n    var handle = ClientVersions.find({\n      _id: 'version-cordova'\n    }).observe({\n      added: checkNewVersionDocument,\n      changed: checkNewVersionDocument\n    });\n  }\n};\n\nMeteor.startup(function () {\n  clearAutoupdateCache(autoupdateVersionCordova);\n});\nMeteor.startup(Autoupdate._retrySubscription);\n\n\n// A helper that removes old directories left from previous autoupdates\nvar clearAutoupdateCache = function (currentVersion) {\n  ensureLocalPathPrefix(function () {\n    // Try to clean up our cache directory, make sure to scan the directory\n    // *before* loading the actual app. This ordering will prevent race\n    // conditions when the app code tries to download a new version before\n    // the old-cache removal has scanned the cache folder.\n    listDirectory(localPathPrefix, {dirsOnly: true}, function (err, names) {\n      // Couldn't get the list of dirs or risking to get into a race with an\n      // on-going update to disk.\n      if (err || updating) {\n        return;\n      }\n\n      _.each(names, function (name) {\n        // Skip the folder with the latest version\n        if (name === currentVersion)\n          return;\n\n        // remove everything else, as we don't want to keep too much cache\n        // around on disk\n        removeDirectory(localPathPrefix + name + '/', function (err) {\n          if (err) {\n            log('Failed to remove an old cache folder '\n                + name + ':' + err.message);\n          } else {\n            log('Successfully removed an old cache folder ' + name);\n          }\n        });\n      });\n    });\n  })\n};\n\n// Cordova File plugin helpers\nvar listDirectory = function (url, options, cb) {\n  if (typeof options === 'function')\n    cb = options, options = {};\n\n  var fail = function (err) { cb(err); };\n  window.resolveLocalFileSystemURL(url, function (entry) {\n    var reader = entry.createReader();\n    reader.readEntries(function (entries) {\n      var names = [];\n      _.each(entries, function (entry) {\n        if (! options.dirsOnly || entry.isDirectory)\n          names.push(entry.name);\n      });\n      cb(null, names);\n    }, fail);\n  }, fail);\n};\n\nvar removeDirectory = function (url, cb) {\n  var fail = function (err) {\n    cb(err);\n  };\n  window.resolveLocalFileSystemURL(url, function (entry) {\n    entry.removeRecursively(function () { cb(); }, fail);\n  }, fail);\n};\n\nvar uriToPath = function (uri) {\n  return decodeURI(uri).replace(/^file:\\/\\//g, '');\n};\n\nvar ensureLocalPathPrefix = function (cb) {\n  if (! localPathPrefix) {\n    if (! cordova.file.dataDirectory) {\n      // Since ensureLocalPathPrefix function is always called on\n      // Meteor.startup, all Cordova plugins should be ready.\n      // XXX Experiments have shown that it is not always the case, even when\n      // the cordova.file symbol is attached, properties like dataDirectory\n      // still can be null. Poll until we are sure the property is attached.\n      console.log(DEBUG_TAG + 'cordova.file.dataDirectory is null, retrying in 20ms');\n      Meteor.setTimeout(_.bind(ensureLocalPathPrefix, null, cb), 20);\n    } else {\n      localPathPrefix = cordova.file.dataDirectory + 'meteor/';\n      cb();\n    }\n  } else {\n    cb();\n  }\n};\n\n"]}