{"version":3,"sources":["meteor://ðŸ’»app/packages/simple_rest/http-connection.js","meteor://ðŸ’»app/packages/simple_rest/http-subscription.js","meteor://ðŸ’»app/packages/simple_rest/rest.js","meteor://ðŸ’»app/packages/simple_rest/list-api.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,oF;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qF;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sF;;;;;;;;;;;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qF","file":"/packages/simple_rest.js","sourcesContent":["// Simulate a DDP connection from HTTP request\nHttpConnection = function () {\n  // no-op now\n};\n","var EventEmitter = Npm.require('events').EventEmitter;\n\n// This file describes something like Subscription in\n// meteor/meteor/packages/ddp/livedata_server.js, but instead of sending\n// over a socket it puts together an HTTP response\nHttpSubscription = function (options) {\n  // Object where the keys are collection names, and then the keys are _ids\n  this.responseData = {};\n\n  this.connection = new HttpConnection(options.request);\n  this.userId = options.userId;\n};\n\n// So that we can listen to ready event in a reasonable way\nMeteor._inherits(HttpSubscription, EventEmitter);\n\n_.extend(HttpSubscription.prototype, {\n  added: function (collection, id, fields) {\n    var self = this;\n\n    check(collection, String);\n    if (id instanceof Mongo.Collection.ObjectID) id = id + '';\n    check(id, String);\n\n    self._ensureCollectionInRes(collection);\n\n    // Make sure to ignore the _id in fields\n    var addedDocument = _.extend({_id: id}, _.omit(fields, '_id'));\n    self.responseData[collection][id] = addedDocument;\n  },\n\n  changed: function (collection, id, fields) {\n    var self = this;\n\n    check(collection, String);\n    if (id instanceof Mongo.Collection.ObjectID) id = id + '';\n    check(id, String);\n\n    self._ensureCollectionInRes(collection);\n\n    var existingDocument = this.responseData[collection][id];\n    var fieldsNoId = _.omit(fields, '_id');\n    _.extend(existingDocument, fieldsNoId);\n\n    // Delete all keys that were undefined in fields (except _id)\n    _.each(fields, function (value, key) {\n      if (value === undefined) {\n        delete existingDocument[key];\n      }\n    });\n  },\n\n  removed: function (collection, id) {\n    var self = this;\n\n    check(collection, String);\n    if (id instanceof Mongo.Collection.ObjectID) id = id + '';\n    check(id, String);\n\n    self._ensureCollectionInRes(collection);\n\n    delete self.responseData[collection][id];\n\n    if (_.isEmpty(self.responseData[collection])) {\n      delete self.responseData[collection];\n    }\n  },\n\n  ready: function () {\n    this.emit('ready', this._generateResponse());\n  },\n\n  onStop: function () {\n    // no-op in HTTP\n  },\n\n  error: function (error) {\n    throw error;\n  },\n\n  _ensureCollectionInRes: function (collection) {\n    this.responseData[collection] = this.responseData[collection] || {};\n  },\n\n  _generateResponse: function () {\n    var output = {};\n\n    _.each(this.responseData, function (documents, collectionName) {\n      output[collectionName] = _.values(documents);\n    });\n\n    return output;\n  },\n});\n","SimpleRest = {};\n\n// Can be used to limit which collections get endpoints:\n// {\n//   collections: ['widgets', 'doodles']\n// }\n// By default all do. Use empty array for none.\n//\n// Also:\n//    objectIdCollections: ['widgets', 'doodles']\nSimpleRest._config = {};\nSimpleRest.configure = function (config) {\n  return _.extend(SimpleRest._config, config);\n};\n\nSimpleRest._methodOptions = {};\n\n// Set options for a particular DDP method that will later be defined\nSimpleRest.setMethodOptions = function (name, options) {\n  check(name, String);\n\n  // Throw an error if the Method is already defined - too late to pass\n  // options\n  if (_.has(Meteor.server.method_handlers, name)) {\n    throw new Error('Must pass options before Method is defined: '\n      + name);\n  }\n\n  options = options || {};\n\n  _.defaults(options, {\n    url: 'methods/' + name,\n    getArgsFromRequest: defaultGetArgsFromRequest,\n    httpMethod: 'post',\n  });\n\n  SimpleRest._methodOptions[name] = options;\n};\n\nvar oldPublish = Meteor.publish;\nMeteor.publish = function (name, handler, options) {\n  options = options || {};\n\n  var httpOptionKeys = [\n    'url',\n    'getArgsFromRequest',\n    'httpMethod',\n  ];\n\n  var httpOptions = _.pick(options, httpOptionKeys);\n  var ddpOptions = _.omit(options, httpOptionKeys);\n\n  // Register DDP publication\n  oldPublish(name, handler, ddpOptions);\n\n  _.defaults(httpOptions, {\n    url: 'publications/' + name,\n    getArgsFromRequest: defaultGetArgsFromRequest,\n    httpMethod: 'get',\n  });\n\n  JsonRoutes.add(httpOptions.httpMethod, httpOptions.url, function (req, res) {\n    var userId = req.userId || null;\n\n    var httpSubscription = new HttpSubscription({\n      request: req,\n      userId: userId,\n    });\n\n    httpSubscription.on('ready', function (response) {\n      JsonRoutes.sendResult(res, {data: response});\n    });\n\n    var handlerArgs = httpOptions.getArgsFromRequest(req);\n\n    var handlerReturn = handler.apply(httpSubscription, handlerArgs);\n\n    // Fast track for publishing cursors - we don't even need livequery here,\n    // just making a normal DB query\n    if (handlerReturn && handlerReturn._publishCursor) {\n      httpPublishCursor(handlerReturn, httpSubscription);\n      httpSubscription.ready();\n    } else if (handlerReturn && _.isArray(handlerReturn)) {\n      // We don't need to run the checks to see if\n      // the cursors overlap and stuff\n      // because calling Meteor.publish will do that for us :]\n      _.each(handlerReturn, function (cursor) {\n        httpPublishCursor(cursor, httpSubscription);\n      });\n\n      httpSubscription.ready();\n    }\n  });\n};\n\nvar oldMethods = Object.getPrototypeOf(Meteor.server).methods;\nMeteor.method = function (name, handler, options) {\n  if (!SimpleRest._methodOptions[name]) {\n    SimpleRest.setMethodOptions(name, options);\n  } else if (options) {\n    throw Error('Options already passed via setMethodOptions.');\n  }\n\n  var methodMap = {};\n  methodMap[name] = handler;\n  oldMethods.call(Meteor.server, methodMap);\n\n  // This is a default collection mutation method, do some special things to\n  // make it more RESTful\n  if (insideDefineMutationMethods) {\n    var collectionName = name.split('/')[1];\n\n    if (_.isArray(SimpleRest._config.collections) &&\n       !_.contains(SimpleRest._config.collections, collectionName)) return;\n\n    var isObjectId = false;\n    if (_.isArray(SimpleRest._config.objectIdCollections) &&\n       _.contains(SimpleRest._config.objectIdCollections, collectionName)) {\n      isObjectId = true;\n    }\n\n    var modifier = name.split('/')[2];\n\n    var collectionUrl = '/' + collectionName;\n    var itemUrl = '/' + collectionName + '/:_id';\n\n    if (modifier === 'insert') {\n      // Post the entire new document\n      addHTTPMethod(name, handler, {\n        httpMethod: 'post',\n        url: collectionUrl,\n      });\n    } else if (modifier === 'update') {\n      // PATCH means you submit an incomplete document, to update the fields\n      // you have passed\n      addHTTPMethod(name, handler, {\n        url: itemUrl,\n        httpMethod: 'patch',\n        getArgsFromRequest: function (req) {\n          var id = req.params._id;\n          if (isObjectId) id = new Mongo.ObjectID(id);\n          return [{ _id: id }, { $set: req.body }];\n        },\n      });\n\n      // We don't have PUT because allow/deny doesn't let you replace documents\n      // you can define it manually if you want\n    } else if (modifier === 'remove') {\n      // Can only remove a single document by the _id\n      addHTTPMethod(name, handler, {\n        url: itemUrl,\n        httpMethod: 'delete',\n        getArgsFromRequest: function (req) {\n          var id = req.params._id;\n          if (isObjectId) id = new Mongo.ObjectID(id);\n          return [{ _id: id }];\n        },\n      });\n    }\n\n    return;\n  }\n\n  addHTTPMethod(name, handler, options);\n};\n\n// Monkey patch _defineMutationMethods so that we can treat them specially\n// inside Meteor.method\nvar insideDefineMutationMethods = false;\nvar oldDMM = Mongo.Collection.prototype._defineMutationMethods;\nMongo.Collection.prototype._defineMutationMethods = function () {\n  insideDefineMutationMethods = true;\n  oldDMM.apply(this, arguments);\n  insideDefineMutationMethods = false;\n};\n\nMeteor.methods = Object.getPrototypeOf(Meteor.server).methods =\n  function (methodMap) {\n    _.each(methodMap, function (handler, name) {\n      Meteor.method(name, handler);\n    });\n  };\n\nfunction addHTTPMethod(methodName, handler, options) {\n  options = options || SimpleRest._methodOptions[methodName] || {};\n\n  options = _.defaults(options, {\n    getArgsFromRequest: defaultGetArgsFromRequest,\n  });\n\n  JsonRoutes.add('options', options.url, function (req, res) {\n    JsonRoutes.sendResult(res);\n  });\n\n  JsonRoutes.add(options.httpMethod, options.url, function (req, res) {\n    var userId = req.userId || null;\n    var statusCode = 200;\n\n    // XXX replace with a real one?\n    var methodInvocation = {\n      userId: userId,\n      setUserId: function () {\n        throw Error('setUserId not implemented in this ' +\n                      'version of simple:rest');\n      },\n\n      isSimulation: false,\n      unblock: function () {\n        // no-op\n      },\n\n      setHttpStatusCode: function (code) {\n        statusCode = code;\n      },\n    };\n\n    var handlerArgs = options.getArgsFromRequest(req);\n    var handlerReturn = handler.apply(methodInvocation, handlerArgs);\n    JsonRoutes.sendResult(res, {\n      code: statusCode,\n      data: handlerReturn,\n    });\n  });\n}\n\nfunction httpPublishCursor(cursor, subscription) {\n  _.each(cursor.fetch(), function (document) {\n    subscription.added(cursor._cursorDescription.collectionName,\n      document._id, document);\n  });\n}\n\nfunction defaultGetArgsFromRequest(req) {\n  var args = [];\n  if (req.method === 'POST') {\n    // by default, the request body is an array which is the arguments\n    args = EJSON.fromJSONValue(req.body);\n\n    // If it's an object, pass the entire object as the only argument\n    if (!_.isArray(args)) {\n      args = [args];\n    }\n  }\n\n  _.each(req.params, function (value, name) {\n    var parsed = parseInt(name, 10);\n\n    if (_.isNaN(parsed)) {\n      throw new Error('REST publish doesn\\'t support parameters ' +\n                      'whose names aren\\'t integers.');\n    }\n\n    args[parsed] = value;\n  });\n\n  return args;\n}\n","/* global JsonRoutes:false - from simple:json-routes package */\n/* global paths:true */\n/* global pathInfo:true */\n\n// publish all API methods\nMeteor.publish('api-routes', function () {\n  var self = this;\n\n  // Deduplicate routes across paths\n  paths = {};\n\n  _.each(JsonRoutes.routes, function (route) {\n    pathInfo = paths[route.path] || { methods: [], path: route.path };\n\n    pathInfo.methods.push(route.method);\n\n    paths[route.path] = pathInfo;\n  });\n\n  _.each(paths, function (pathInfo, path) {\n    self.added('api-routes', path, pathInfo);\n  });\n\n  self.ready();\n});\n"]}